---
phase: 01-foundation
plan: 02
type: execute
---

<objective>
Build PowerShell execution engine with Exchange Online connection management.

Purpose: This is the core integration layer - all mailbox operations depend on reliable PowerShell execution with proper session management.
Output: Working PowerShell executor that can connect to Exchange Online and execute commands with JSON output.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-01-SUMMARY.md

**From PROJECT.md:**
- PowerShell Core 7.x with Exchange Online Module
- subprocess for PowerShell integration (decided over PSSession)
- Auto-reconnect on timeout
- Retry logic with exponential backoff

**Key Exchange Online cmdlets:**
- Connect-ExchangeOnline (with -ShowBanner:$false for automation)
- Get-EXOMailbox -InactiveMailboxOnly
- Disconnect-ExchangeOnline -Confirm:$false

**Critical considerations:**
- Exchange Online sessions timeout after 15-30 minutes of inactivity
- Use -ResultSize unlimited carefully (can be slow)
- JSON output via ConvertTo-Json for parsing
- MFA requires device code flow (handled by MSAL in 01-03)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PowerShell executor class with subprocess management</name>
  <files>src/core/powershell_executor.py</files>
  <action>
    Create PowerShell execution wrapper:

    1. PowerShellExecutor class with:
       - __init__(self, powershell_path: str = "pwsh") - detect pwsh vs powershell.exe
       - execute(command: str, timeout: int = 120) -> PowerShellResult
       - execute_script(script_path: Path, params: dict) -> PowerShellResult

    2. PowerShellResult dataclass:
       - success: bool
       - output: str (raw stdout)
       - error: str (stderr)
       - return_code: int
       - duration_ms: int

    3. Implementation details:
       - Use subprocess.run with capture_output=True
       - Set encoding='utf-8' for proper Unicode handling
       - Wrap commands in try/catch for better error messages
       - Add -NoProfile -NonInteractive flags for automation
       - Log all commands at DEBUG level (sanitize sensitive data)

    4. Error handling:
       - PowerShellError exception class with command, error_message, return_code
       - Timeout handling with configurable default
       - Parse PowerShell error streams properly

    Do NOT use asyncio subprocess - keep it synchronous for simplicity.
  </action>
  <verify>python -c "from src.core.powershell_executor import PowerShellExecutor; ps = PowerShellExecutor(); r = ps.execute('Write-Output \"Hello\"'); print(r.output)"</verify>
  <done>PowerShell commands execute successfully, errors captured properly, timeouts work</done>
</task>

<task type="auto">
  <name>Task 2: Implement Exchange Online connection management</name>
  <files>src/core/exchange_connection.py</files>
  <action>
    Create Exchange Online connection manager:

    1. ExchangeConnection class with:
       - __init__(self, executor: PowerShellExecutor, config: Config)
       - connect(access_token: str) -> bool
       - disconnect() -> None
       - is_connected() -> bool
       - ensure_connected() -> None (reconnect if needed)
       - _connection_state: ConnectionState enum (disconnected, connecting, connected, error)

    2. Connection method using access token from MSAL:
       ```powershell
       Connect-ExchangeOnline -AccessToken $token -Organization $tenant -ShowBanner:$false
       ```

    3. Connection health check:
       - Test connection with: Get-EXOMailbox -ResultSize 1
       - Track last_activity timestamp
       - Auto-reconnect if session expired (handle "session expired" errors)

    4. Retry logic with exponential backoff:
       - max_retries: 3 (from config)
       - base_delay: 1 second
       - max_delay: 30 seconds
       - Exponential: delay = min(base * 2^attempt, max_delay)

    5. Graceful disconnect:
       - Always call Disconnect-ExchangeOnline -Confirm:$false
       - Handle case where session already disconnected

    Use @contextmanager for connection lifecycle if helpful.
  </action>
  <verify>Unit test with mocked PowerShell executor verifies connection flow</verify>
  <done>Connection management handles connect/disconnect/reconnect, retry logic works, state tracking accurate</done>
</task>

<task type="auto">
  <name>Task 3: Add command builder and JSON output parsing</name>
  <files>src/utils/command_builder.py, src/utils/ps_parser.py</files>
  <action>
    Create PowerShell command helpers:

    1. src/utils/command_builder.py with CommandBuilder class:
       - build_get_inactive_mailboxes(result_size: int, properties: list[str]) -> str
       - build_get_mailbox_statistics(identity: str) -> str
       - build_get_mailbox_holds(identity: str) -> str
       - _escape_parameter(value: str) -> str (handle special chars)
       - _format_properties(props: list[str]) -> str

    2. Command templates (return full PowerShell commands):
       ```powershell
       Get-EXOMailbox -InactiveMailboxOnly -ResultSize {size} -PropertySets All |
         Select-Object {properties} |
         ConvertTo-Json -Depth 10
       ```

    3. src/utils/ps_parser.py with:
       - parse_json_output(output: str) -> list[dict] | dict
       - Handle single object vs array response
       - Handle empty response (return empty list)
       - Handle malformed JSON with helpful error messages
       - Normalize property names (PascalCase -> snake_case optional)

    4. Error response parsing:
       - Detect common Exchange Online errors
       - Map error codes to user-friendly messages
       - Extract relevant details from error XML

    Keep commands simple - complex logic should be in Python, not PowerShell.
  </action>
  <verify>python -c "from src.utils.command_builder import CommandBuilder; cb = CommandBuilder(); print(cb.build_get_inactive_mailboxes(100, ['DisplayName', 'PrimarySmtpAddress']))"</verify>
  <done>Commands generate correctly, JSON parsing handles all cases, error extraction works</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] PowerShell executor runs basic commands successfully
- [ ] Command builder generates valid PowerShell syntax
- [ ] JSON parser handles arrays, single objects, and empty responses
- [ ] Error handling captures PowerShell errors with details
- [ ] Connection manager state machine is correct
- [ ] Unit tests pass for command builder and parser
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- PowerShell execution is reliable with proper error handling
- Connection management handles reconnection gracefully
- Commands are parameterized safely (no injection vulnerabilities)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
