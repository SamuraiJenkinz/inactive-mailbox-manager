---
phase: 01-foundation
plan: 03
type: execute
---

<objective>
Implement SQLite caching layer and MSAL authentication with device code flow.

Purpose: Enable offline access to mailbox data and provide secure Azure AD authentication with MFA support.
Output: Working SQLite cache for mailbox data and MSAL authentication that handles device code flow with token persistence.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md

**From PROJECT.md:**
- SQLite for local cache and audit logs
- MSAL for Azure AD authentication
- Must support MFA and conditional access policies
- Performance: list 10K mailboxes in <5s from cache

**MSAL device code flow pattern (from research):**
```python
app = msal.PublicClientApplication(client_id, authority=authority)
flow = app.initiate_device_flow(scopes=scopes)
print(flow["message"])  # Shows code and URL
result = app.acquire_token_by_device_flow(flow)
```

**Required Azure AD scopes for Exchange Online:**
- https://outlook.office365.com/.default
- Or specific: Mail.Read, User.Read, etc.

**Token caching:**
- MSAL supports file-based token cache via SerializableTokenCache
- Tokens persist across sessions
- Silent token refresh using refresh token
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SQLite database layer with schema</name>
  <files>src/data/database.py, src/data/models.py</files>
  <action>
    Create SQLite database management:

    1. src/data/models.py with dataclasses:
       - InactiveMailbox: identity (guid), display_name, primary_smtp, when_soft_deleted, age_days, size_mb, item_count, license_type, monthly_cost, hold_types (JSON), recovery_eligible, recovery_blockers (JSON), operating_company, department, last_updated
       - AuditLogEntry: id, timestamp, operation, identity, user, details (JSON), result, error_message

    2. src/data/database.py with DatabaseManager class:
       - __init__(self, db_path: Path)
       - initialize() -> None (create tables if not exist)
       - get_connection() -> sqlite3.Connection (with row_factory)

    3. Schema creation:
       ```sql
       CREATE TABLE IF NOT EXISTS inactive_mailboxes (
         identity TEXT PRIMARY KEY,
         display_name TEXT,
         primary_smtp TEXT,
         when_soft_deleted TEXT,
         age_days INTEGER,
         size_mb REAL,
         item_count INTEGER,
         license_type TEXT,
         monthly_cost REAL,
         hold_types TEXT,  -- JSON array
         recovery_eligible INTEGER,
         recovery_blockers TEXT,  -- JSON array
         operating_company TEXT,
         department TEXT,
         last_updated TEXT
       );

       CREATE TABLE IF NOT EXISTS audit_log (
         id INTEGER PRIMARY KEY AUTOINCREMENT,
         timestamp TEXT NOT NULL,
         operation TEXT NOT NULL,
         identity TEXT,
         user TEXT,
         details TEXT,  -- JSON
         result TEXT,
         error_message TEXT
       );

       CREATE INDEX IF NOT EXISTS idx_mailboxes_smtp ON inactive_mailboxes(primary_smtp);
       CREATE INDEX IF NOT EXISTS idx_mailboxes_deleted ON inactive_mailboxes(when_soft_deleted);
       CREATE INDEX IF NOT EXISTS idx_audit_timestamp ON audit_log(timestamp);
       ```

    4. CRUD operations:
       - upsert_mailbox(mailbox: InactiveMailbox) -> None
       - upsert_mailboxes(mailboxes: list[InactiveMailbox]) -> int (batch insert, return count)
       - get_all_mailboxes() -> list[InactiveMailbox]
       - get_mailbox(identity: str) -> InactiveMailbox | None
       - search_mailboxes(query: str) -> list[InactiveMailbox] (search display_name, primary_smtp)
       - get_cache_stats() -> dict (count, oldest, newest, size_bytes)
       - clear_cache() -> None

    Use sqlite3 built-in module. Enable WAL mode for better concurrency.
  </action>
  <verify>python -c "from src.data.database import DatabaseManager; db = DatabaseManager('test.db'); db.initialize(); print('Tables created')"</verify>
  <done>SQLite database initializes, schema creates correctly, CRUD operations work, WAL mode enabled</done>
</task>

<task type="auto">
  <name>Task 2: Implement MSAL device code flow authentication</name>
  <files>src/utils/authentication.py</files>
  <action>
    Create Azure AD authentication using MSAL:

    1. src/utils/authentication.py with Authenticator class:
       - __init__(self, client_id: str, tenant_id: str, cache_path: Path)
       - authenticate() -> str (returns access token)
       - get_token_silent() -> str | None (try silent refresh first)
       - _device_code_flow() -> str (interactive device code)
       - is_authenticated() -> bool
       - logout() -> None (clear cached tokens)

    2. Device code flow implementation:
       ```python
       app = msal.PublicClientApplication(
           client_id,
           authority=f"https://login.microsoftonline.com/{tenant_id}",
           token_cache=self._cache
       )

       # Try silent first
       accounts = app.get_accounts()
       if accounts:
           result = app.acquire_token_silent(scopes, account=accounts[0])
           if result and "access_token" in result:
               return result["access_token"]

       # Fall back to device code
       flow = app.initiate_device_flow(scopes=["https://outlook.office365.com/.default"])
       print(flow["message"])  # User sees: "To sign in, use a web browser..."
       result = app.acquire_token_by_device_flow(flow)
       ```

    3. Token cache persistence:
       - Use MSAL's SerializableTokenCache
       - Save to file: ~/.imm/token_cache.bin (or config-specified path)
       - Load on startup, save after each token acquisition
       - Encrypt cache file using user's Windows credentials (optional, note in comments)

    4. Error handling:
       - AuthenticationError exception with error_code, message, details
       - Handle: user_cancelled, timeout, invalid_grant, network_error
       - Clear cache on invalid_grant (token revoked)

    5. Configuration:
       - Scopes should be configurable (default: Exchange Online)
       - Timeout for device code flow: 5 minutes

    Use msal library (NOT azure-identity). Device code is best for CLI tools.
  </action>
  <verify>python -c "from src.utils.authentication import Authenticator; a = Authenticator('test', 'test', Path('.'))" (construction only - actual auth needs real Azure AD app)</verify>
  <done>MSAL authentication class created, device code flow implemented, token caching works</done>
</task>

<task type="auto">
  <name>Task 3: Add audit logging and session persistence</name>
  <files>src/data/audit_logger.py, src/data/session.py</files>
  <action>
    Create audit logging and session management:

    1. src/data/audit_logger.py with AuditLogger class:
       - __init__(self, db: DatabaseManager)
       - log_operation(operation: str, identity: str | None, details: dict, result: str, error: str | None) -> None
       - get_operations(start_date: datetime, end_date: datetime) -> list[AuditLogEntry]
       - get_operations_for_mailbox(identity: str) -> list[AuditLogEntry]
       - export_to_json(path: Path, start_date: datetime, end_date: datetime) -> int
       - prune_old_entries(retention_days: int) -> int (delete old entries)

    2. Operation types enum:
       - CONNECT, DISCONNECT
       - LIST_MAILBOXES, GET_MAILBOX_DETAILS
       - RECOVER_MAILBOX, RESTORE_MAILBOX
       - REMOVE_HOLD, CHANGE_HOLD
       - BULK_OPERATION
       - EXPORT_DATA
       - ERROR

    3. src/data/session.py with SessionManager class:
       - __init__(self, config: Config, db: DatabaseManager, authenticator: Authenticator)
       - start_session() -> None (authenticate, connect to Exchange)
       - end_session() -> None (disconnect, cleanup)
       - get_session_info() -> dict (connected, tenant, user, token_expires)
       - @property connection: ExchangeConnection
       - @property is_active: bool

    4. Session lifecycle:
       - Check for cached token on startup
       - If valid token: connect silently
       - If no token or expired: run device code flow
       - Log all session events to audit log

    5. Context manager support:
       ```python
       with SessionManager(config, db, auth) as session:
           # session.connection is ready to use
           pass
       # Auto-disconnect on exit
       ```

    Audit log is critical for compliance - never skip logging.
  </action>
  <verify>python -c "from src.data.audit_logger import AuditLogger, OperationType; print(OperationType.CONNECT.value)"</verify>
  <done>Audit logging captures all operations, session manager handles lifecycle, context manager works</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] SQLite database creates and initializes correctly
- [ ] Mailbox CRUD operations work (insert, query, search)
- [ ] MSAL Authenticator class instantiates without errors
- [ ] Token cache file is created/loaded correctly
- [ ] Audit logger writes entries to database
- [ ] Session manager coordinates auth + connection
- [ ] All imports resolve without circular dependencies
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- SQLite operations are fast (batch insert 10K rows < 5s)
- MSAL device code flow is implemented correctly
- Audit trail captures all operations with timestamps
- Phase 1 foundation is complete and ready for Phase 2
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`

**Phase 1 Complete Checklist:**
- [ ] Project structure established
- [ ] Configuration system working
- [ ] Logging foundation ready
- [ ] PowerShell executor operational
- [ ] Exchange connection management ready
- [ ] SQLite cache layer functional
- [ ] MSAL authentication implemented
- [ ] Audit logging in place
- [ ] Session management coordinated
</output>
