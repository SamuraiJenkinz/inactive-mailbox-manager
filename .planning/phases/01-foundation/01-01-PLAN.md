---
phase: 01-foundation
plan: 01
type: execute
---

<objective>
Set up project scaffolding, configuration system, and logging foundation.

Purpose: Establish the project structure that all subsequent phases build upon. Clean, well-organized foundation enables faster development.
Output: Working Python project with pyproject.toml, configuration loader, and structured logging.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Tech stack from PROJECT.md:**
- Python 3.10+
- YAML for configuration
- Rich for terminal formatting
- SQLite for local storage

**Project structure from spec:**
```
InactiveMailboxManager/
├── main.py
├── config/
│   ├── settings.yaml
│   └── branding.yaml
├── core/
├── ui/
├── data/
├── utils/
└── tests/
```

**Prior decisions:**
- SQLite for local storage (no external dependencies)
- Brutalist dark theme (terminal green on black)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create project scaffolding with pyproject.toml</name>
  <files>pyproject.toml, main.py, src/__init__.py, src/core/__init__.py, src/ui/__init__.py, src/data/__init__.py, src/utils/__init__.py, tests/__init__.py</files>
  <action>
    Create Python project structure using src layout:

    1. Create pyproject.toml with:
       - name: inactive-mailbox-manager
       - version: 0.1.0
       - python_requires: >=3.10
       - dependencies: msal, pyyaml, rich, textual, pandas, openpyxl
       - dev dependencies: pytest, pytest-cov, black, ruff, mypy
       - entry point: imm = src.main:main

    2. Create directory structure:
       - src/ (main package)
       - src/core/ (PowerShell executor, mailbox operations, hold analyzer, cost calculator, validator)
       - src/ui/ (terminal_ui, gui_main, components/, styles/)
       - src/data/ (cache, audit_logger, export_manager)
       - src/utils/ (authentication, command_builder, error_handler, formatting)
       - config/ (settings.yaml, branding.yaml)
       - tests/

    3. Create main.py with CLI argument parser skeleton using argparse:
       - --mode terminal|gui (default: terminal)
       - --config path/to/config.yaml
       - --test-connection (test Exchange Online connection)
       - --refresh-cache (force cache refresh)

    Use src layout (NOT flat layout) for proper package isolation.
  </action>
  <verify>python -c "import src" succeeds without errors</verify>
  <done>Project structure created, pyproject.toml valid, main.py has argument parser</done>
</task>

<task type="auto">
  <name>Task 2: Implement configuration system with YAML loader</name>
  <files>src/utils/config.py, config/settings.yaml, config/branding.yaml</files>
  <action>
    Create configuration management system:

    1. config/settings.yaml template with sections:
       - connection: tenant_id, default_result_size (10000), connection_timeout_minutes (30), auto_reconnect (true)
       - cost_analysis: license_costs (E5: 38.00, E3: 20.00, F3: 10.00), currency (USD)
       - ui: theme (brutalist_dark), default_view (terminal), rows_per_page (50), refresh_interval_minutes (60)
       - cache: enabled (true), refresh_on_startup (false), cache_duration_hours (24)
       - audit: enabled (true), log_level (INFO), retention_days (365)
       - bulk_operations: max_batch_size (100), delay_between_operations_seconds (2)
       - export: default_format (xlsx), include_charts (true)

    2. config/branding.yaml with brutalist theme:
       - colors: background (#0d0d0d), foreground (#00ff00), accent (#00ff00), error (#ff0000), warning (#ffff00)
       - fonts: primary (Consolas), fallback (Cascadia Mono, monospace)

    3. src/utils/config.py with:
       - Config dataclass with nested dataclasses for each section
       - load_config(path: Path) -> Config function
       - Support for environment variable overrides (IMM_TENANT_ID, etc.)
       - Validation of required fields
       - Default config path: ./config/settings.yaml

    Use pyyaml for parsing. Use dataclasses (not pydantic) for simplicity.
  </action>
  <verify>python -c "from src.utils.config import load_config; c = load_config(); print(c.connection.tenant_id)"</verify>
  <done>Config loads from YAML, environment overrides work, validation catches missing required fields</done>
</task>

<task type="auto">
  <name>Task 3: Set up structured logging with Rich</name>
  <files>src/utils/logging.py, src/utils/__init__.py</files>
  <action>
    Create logging foundation using Rich:

    1. src/utils/logging.py with:
       - setup_logging(level: str, log_file: Path | None) function
       - Use Rich's Console and logging handler for beautiful terminal output
       - File handler for persistent logs (JSON format for parsing)
       - Log format: timestamp, level, module, message
       - Support log levels: DEBUG, INFO, WARNING, ERROR, CRITICAL

    2. Create get_logger(name: str) -> Logger helper that returns configured logger

    3. Add RichHandler for console output with:
       - Syntax highlighting for tracebacks
       - Colored log levels
       - Timestamps in dim style

    4. Add RotatingFileHandler for file output:
       - Max 10MB per file
       - Keep 5 backup files
       - JSON format for SIEM integration

    Use Python's built-in logging module with Rich integration (NOT loguru or structlog).
  </action>
  <verify>python -c "from src.utils.logging import setup_logging, get_logger; setup_logging('DEBUG'); log = get_logger('test'); log.info('Test message')"</verify>
  <done>Logging outputs to both console (Rich formatted) and file (JSON), log rotation works</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "import src"` succeeds
- [ ] `python main.py --help` shows argument parser help
- [ ] Config loads from settings.yaml
- [ ] Environment variable override works (set IMM_TENANT_ID=test)
- [ ] Logging outputs to console with Rich formatting
- [ ] No import errors or circular dependencies
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Project structure matches spec
- Configuration system is type-safe with dataclasses
- Logging is production-ready with rotation
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
