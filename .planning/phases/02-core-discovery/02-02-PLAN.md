---
phase: 02-core-discovery
plan: 02
type: execute
---

<objective>
Implement comprehensive hold type detection and analysis for inactive mailboxes.

Purpose: Identify all hold types with proper hierarchy and user-friendly names.
Output: Working hold analyzer that decodes InPlaceHolds GUIDs and identifies all hold sources.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-discovery/02-01-SUMMARY.md

**From PROJECT.md:**
- Must identify ALL hold types with visual hierarchy
- Hold types: Litigation Hold, In-Place Hold, eDiscovery, Retention Policies, Delay Hold
- InPlaceHolds contain GUIDs with prefixes indicating hold type

**Hold GUID prefixes (from research):**
- UniH: Unified Hold (eDiscovery case hold)
- mbx: Mailbox-level query-based hold
- skp: Skype for Business hold
- cld: Cloud-based hold
- grp: Group-based hold
- Plain GUID: Often a retention policy

**Additional hold properties:**
- LitigationHoldEnabled (bool)
- LitigationHoldDate, LitigationHoldOwner, LitigationHoldDuration
- RetentionPolicy (name of policy)
- RetentionHoldEnabled (bool)
- DelayHoldApplied (bool) - 30-day delay after hold removal
- DelayReleaseHoldApplied (bool)
- ComplianceTagHoldApplied (bool) - retention label hold

**Available from Phase 1:**
- parse_hold_guids() in ps_parser.py (basic GUID parsing)
- CommandBuilder.build_get_mailbox_holds() for retrieving hold info
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create hold type definitions and analyzer</name>
  <files>src/core/hold_analyzer.py</files>
  <action>
    Create comprehensive hold analysis:

    1. HoldType enum with all possible hold types:
       - LITIGATION_HOLD
       - EDISCOVERY_CASE_HOLD (UniH prefix)
       - RETENTION_POLICY
       - RETENTION_LABEL (ComplianceTagHoldApplied)
       - IN_PLACE_HOLD (legacy)
       - DELAY_HOLD (30-day delay)
       - SKYPE_HOLD (skp prefix)
       - GROUP_HOLD (grp prefix)
       - UNKNOWN

    2. Hold dataclass:
       - hold_id: str (GUID or identifier)
       - hold_type: HoldType
       - display_name: str (user-friendly name)
       - description: str | None
       - source: str | None (e.g., "Compliance Center", "Exchange Admin")
       - applied_date: datetime | None
       - applied_by: str | None
       - is_inherited: bool (from retention policy vs explicit)

    3. HoldAnalyzer class:
       - __init__(self, session: SessionManager)
       - analyze_mailbox_holds(identity: str) -> MailboxHoldInfo
       - get_hold_details(hold_id: str) -> Hold | None
       - decode_hold_guid(guid: str) -> Hold
       - get_retention_policies() -> list[RetentionPolicy] (cached)

    4. MailboxHoldInfo dataclass:
       - identity: str
       - display_name: str
       - total_hold_count: int
       - holds: list[Hold]
       - has_litigation_hold: bool
       - has_ediscovery_hold: bool
       - has_retention_policy: bool
       - has_delay_hold: bool
       - can_be_removed: bool (no active holds)
       - removal_blockers: list[str]

    Focus on accurate hold detection - this is critical for recovery decisions.
  </action>
  <verify>python -c "from src.core.hold_analyzer import HoldAnalyzer, HoldType, Hold; print(HoldType.LITIGATION_HOLD.value)"</verify>
  <done>HoldAnalyzer can identify all hold types from mailbox data</done>
</task>

<task type="auto">
  <name>Task 2: Implement retention policy resolution</name>
  <files>src/core/hold_analyzer.py (update), src/data/models.py (update)</files>
  <action>
    Add retention policy lookup and resolution:

    1. Add RetentionPolicy dataclass to models.py:
       - policy_id: str (GUID)
       - name: str
       - description: str | None
       - is_default: bool
       - retention_tags: list[str]
       - applied_mailbox_count: int | None

    2. Add to HoldAnalyzer:
       - _retention_policy_cache: dict[str, RetentionPolicy]
       - _fetch_retention_policies() -> None
       - resolve_retention_policy(policy_id: str) -> RetentionPolicy | None
       - get_policy_by_name(name: str) -> RetentionPolicy | None

    3. Policy fetching:
       ```powershell
       Get-RetentionPolicy | Select-Object Name, Guid, RetentionPolicyTagLinks, IsDefault |
           ConvertTo-Json -Depth 10
       ```

    4. Integration with hold analysis:
       - When hold GUID matches a retention policy, include policy name
       - Flag mailboxes with default vs explicit policies
       - Note: RetentionPolicy property on mailbox is the policy NAME, not GUID

    Cache retention policies - they don't change frequently.
  </action>
  <verify>python -c "from src.data.models import RetentionPolicy; print('RetentionPolicy imported')"</verify>
  <done>Retention policies can be resolved to friendly names</done>
</task>

<task type="auto">
  <name>Task 3: Add hold hierarchy and removal eligibility</name>
  <files>src/core/hold_analyzer.py (update)</files>
  <action>
    Implement hold hierarchy and removal logic:

    1. Hold hierarchy (strongest to weakest):
       - Litigation Hold (explicit legal hold)
       - eDiscovery Case Hold (legal/compliance)
       - In-Place Hold (legacy, but still enforced)
       - Retention Policy (org-wide or targeted)
       - Retention Label (content-level)
       - Delay Hold (temporary, 30 days)

    2. Add to HoldAnalyzer:
       - get_hold_hierarchy(holds: list[Hold]) -> list[Hold] (sorted by strength)
       - get_strongest_hold(holds: list[Hold]) -> Hold | None
       - can_remove_mailbox(identity: str) -> tuple[bool, list[str]] (eligible, blockers)
       - get_removal_steps(identity: str) -> list[str] (ordered steps to remove holds)

    3. Removal eligibility logic:
       ```python
       def can_remove_mailbox(self, identity: str) -> tuple[bool, list[str]]:
           hold_info = self.analyze_mailbox_holds(identity)
           blockers = []

           if hold_info.has_litigation_hold:
               blockers.append("Litigation Hold must be removed by legal/compliance")
           if hold_info.has_ediscovery_hold:
               blockers.append("eDiscovery case hold must be released in Compliance Center")
           if hold_info.has_delay_hold:
               blockers.append("Delay hold active - wait 30 days or contact support")

           return (len(blockers) == 0, blockers)
       ```

    4. Hold summary for UI:
       - get_hold_summary(identity: str) -> dict with counts by type
       - Format holds for display with icons/indicators

    This is critical for the recovery wizard in Phase 3.
  </action>
  <verify>python -c "from src.core.hold_analyzer import HoldAnalyzer; print('HoldAnalyzer with hierarchy imported')"</verify>
  <done>Hold hierarchy works, removal eligibility accurately identifies blockers</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] HoldType enum has all hold types
- [ ] Hold dataclass captures all relevant properties
- [ ] HoldAnalyzer decodes GUID prefixes correctly
- [ ] Retention policy resolution works
- [ ] Hold hierarchy correctly orders holds
- [ ] Removal eligibility identifies all blockers
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Hold analysis is accurate and comprehensive
- Retention policies resolve to friendly names
- Recovery eligibility logic is sound
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-discovery/02-02-SUMMARY.md`
</output>
