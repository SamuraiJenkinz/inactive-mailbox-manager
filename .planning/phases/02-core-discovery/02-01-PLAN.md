---
phase: 02-core-discovery
plan: 01
type: execute
---

<objective>
Implement mailbox inventory retrieval that bypasses the 5,000 mailbox limit in Microsoft Purview.

Purpose: Core data retrieval - all other features depend on having complete mailbox inventory.
Output: Working mailbox service that can retrieve ALL inactive mailboxes with pagination and caching.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-03-SUMMARY.md

**From PROJECT.md:**
- Must handle >5,000 inactive mailboxes (target: 80,000+ users)
- Performance: list 10K mailboxes <5s from cache
- Use Get-EXOMailbox -InactiveMailboxOnly with pagination

**Exchange Online pagination pattern:**
- Use -ResultSize with reasonable batch size (1000-5000)
- Track total count separately with (Get-EXOMailbox -InactiveMailboxOnly).Count
- No cursor-based pagination in EXO - use client-side collection

**Available from Phase 1:**
- PowerShellExecutor for command execution
- ExchangeConnection for session management
- DatabaseManager for caching
- CommandBuilder for safe command generation
- SessionManager for coordinating all components
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create mailbox service with inventory retrieval</name>
  <files>src/core/mailbox_service.py</files>
  <action>
    Create the main mailbox service:

    1. MailboxService class with:
       - __init__(self, session: SessionManager)
       - get_all_mailboxes(force_refresh: bool = False) -> list[InactiveMailbox]
       - get_mailbox(identity: str) -> InactiveMailbox | None
       - get_mailbox_count() -> int
       - refresh_cache() -> int (returns count of mailboxes cached)
       - search(query: str) -> list[InactiveMailbox]

    2. Retrieval strategy:
       - Check cache freshness first (use cache_duration_hours from config)
       - If cache valid and not force_refresh: return from cache
       - If cache stale or force_refresh: fetch from Exchange Online
       - Use batch retrieval with progress callback

    3. Batch retrieval implementation:
       ```python
       def _fetch_all_from_exchange(
           self,
           progress_callback: Callable[[int, int], None] | None = None
       ) -> list[InactiveMailbox]:
           # Get total count first
           count_result = self._session.connection.execute_command(
               self._command_builder.build_count_inactive_mailboxes()
           )
           total = int(count_result.output.strip())

           # Fetch all with -ResultSize Unlimited
           # (Exchange handles batching internally)
           result = self._session.connection.execute_command(
               self._command_builder.build_get_inactive_mailboxes(
                   result_size="Unlimited",
                   properties=self.DEFAULT_PROPERTIES
               ),
               timeout=600  # 10 minutes for large tenants
           )

           # Parse JSON output
           data = parse_json_output(result.output)
           mailboxes = [InactiveMailbox.from_exchange_data(m) for m in data]

           # Cache results
           self._db.upsert_mailboxes(mailboxes)
           self._db.set_last_refresh()

           return mailboxes
       ```

    4. Error handling:
       - Handle throttling (wait and retry)
       - Handle session timeout (auto-reconnect via SessionManager)
       - Log all operations to audit trail

    Use the existing CommandBuilder and parse_json_output from Phase 1.
  </action>
  <verify>python -c "from src.core.mailbox_service import MailboxService; print('MailboxService imported')"</verify>
  <done>MailboxService class created, can retrieve mailboxes from Exchange and cache</done>
</task>

<task type="auto">
  <name>Task 2: Add mailbox statistics and detail retrieval</name>
  <files>src/core/mailbox_service.py (update)</files>
  <action>
    Extend MailboxService with detailed information retrieval:

    1. Add methods:
       - get_mailbox_statistics(identity: str) -> MailboxStatistics | None
       - get_mailbox_details(identity: str) -> InactiveMailbox (full refresh from Exchange)
       - enrich_mailbox(mailbox: InactiveMailbox) -> InactiveMailbox (add statistics)

    2. Create MailboxStatistics dataclass in models.py:
       - identity: str
       - display_name: str
       - total_size_bytes: int
       - item_count: int
       - deleted_item_size_bytes: int
       - deleted_item_count: int
       - last_logon: datetime | None
       - last_logoff: datetime | None

    3. Size parsing:
       - Exchange returns sizes like "1.5 GB (1,610,612,736 bytes)"
       - Use parse_size_value() from ps_parser.py
       - Store size in MB in InactiveMailbox model

    4. Update InactiveMailbox from statistics:
       - Populate size_mb from TotalItemSize
       - Populate item_count from ItemCount

    Keep operations efficient - only fetch details when explicitly requested.
  </action>
  <verify>python -c "from src.data.models import MailboxStatistics; print('MailboxStatistics imported')"</verify>
  <done>Statistics retrieval works, mailbox enrichment populates size and item count</done>
</task>

<task type="auto">
  <name>Task 3: Add cache management and refresh logic</name>
  <files>src/core/mailbox_service.py (update), src/core/cache_manager.py</files>
  <action>
    Create cache management utilities:

    1. src/core/cache_manager.py with CacheManager class:
       - __init__(self, db: DatabaseManager, config: Config)
       - is_cache_valid() -> bool (check age vs cache_duration_hours)
       - get_cache_age_hours() -> float
       - should_refresh() -> bool
       - invalidate_cache() -> None
       - get_stats() -> CacheStats

    2. Cache validation logic:
       - Check last_refresh from cache_metadata table
       - Compare against config.cache.cache_duration_hours
       - Return True if cache is fresh enough

    3. Update MailboxService:
       - Use CacheManager for cache decisions
       - Add auto_refresh parameter to get_all_mailboxes()
       - Log cache hits/misses for debugging

    4. Performance optimization:
       - Return cached data immediately when valid
       - Batch database operations
       - Use indexes for search queries

    Target: 10K mailboxes from cache in <5 seconds.
  </action>
  <verify>python -c "from src.core.cache_manager import CacheManager; print('CacheManager imported')"</verify>
  <done>Cache management works, refresh logic respects config, performance meets target</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] MailboxService can retrieve mailboxes (even if test tenant has none)
- [ ] MailboxStatistics dataclass is defined
- [ ] CacheManager validates cache freshness
- [ ] All imports resolve without circular dependencies
- [ ] Audit logging captures mailbox operations
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- MailboxService integrates with SessionManager
- Cache logic respects configuration
- Operations are logged to audit trail
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-discovery/02-01-SUMMARY.md`
</output>
