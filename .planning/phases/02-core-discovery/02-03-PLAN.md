---
phase: 02-core-discovery
plan: 03
type: execute
---

<objective>
Implement filtering, search, and data display capabilities for mailbox inventory.

Purpose: Enable users to find and organize mailboxes efficiently.
Output: Working filter/search system with sorting and basic data export.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-discovery/02-01-SUMMARY.md
@.planning/phases/02-core-discovery/02-02-SUMMARY.md

**From PROJECT.md:**
- Filter by: hold type, age bracket, license type, operating company, size
- Search by: display name, email, UPN
- Sort by: any column
- Export to: CSV, Excel (full export in Phase 4)

**Filter dimensions:**
- Hold type: Has holds, No holds, Litigation, eDiscovery, Retention, Delay
- Age bracket: <30 days, 30-90 days, 90-180 days, 180-365 days, >365 days
- License type: E5, E3, E1, F3, Exchange Online Plan 1/2
- Operating company: From AD attribute (if populated)
- Size: <100MB, 100MB-1GB, 1-5GB, 5-10GB, >10GB
- Recovery: Eligible, Blocked

**Available from Phase 2:**
- MailboxService for data retrieval
- HoldAnalyzer for hold information
- DatabaseManager with indexed columns
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create filter and search service</name>
  <files>src/core/filter_service.py</files>
  <action>
    Create comprehensive filtering system:

    1. FilterCriteria dataclass:
       - hold_types: list[HoldType] | None
       - has_any_hold: bool | None
       - age_min_days: int | None
       - age_max_days: int | None
       - license_types: list[str] | None
       - operating_companies: list[str] | None
       - size_min_mb: float | None
       - size_max_mb: float | None
       - recovery_eligible: bool | None
       - search_query: str | None

    2. SortCriteria dataclass:
       - field: str (column name)
       - ascending: bool = True

    3. FilterService class:
       - __init__(self, db: DatabaseManager)
       - filter_mailboxes(criteria: FilterCriteria, sort: SortCriteria | None = None) -> list[InactiveMailbox]
       - search_mailboxes(query: str) -> list[InactiveMailbox]
       - get_distinct_values(field: str) -> list[str] (for filter dropdowns)
       - get_filter_counts(criteria: FilterCriteria) -> dict[str, int] (counts per dimension)

    4. SQL-based filtering:
       ```python
       def _build_filter_query(self, criteria: FilterCriteria) -> tuple[str, list]:
           conditions = []
           params = []

           if criteria.age_min_days is not None:
               conditions.append("age_days >= ?")
               params.append(criteria.age_min_days)

           if criteria.search_query:
               conditions.append("(display_name LIKE ? OR primary_smtp LIKE ?)")
               pattern = f"%{criteria.search_query}%"
               params.extend([pattern, pattern])

           # ... more conditions

           where = " AND ".join(conditions) if conditions else "1=1"
           return where, params
       ```

    Use database indexes for efficient filtering.
  </action>
  <verify>python -c "from src.core.filter_service import FilterService, FilterCriteria; print('FilterService imported')"</verify>
  <done>FilterService can filter by all dimensions, search works</done>
</task>

<task type="auto">
  <name>Task 2: Add aggregation and statistics</name>
  <files>src/core/filter_service.py (update), src/core/statistics_service.py</files>
  <action>
    Create statistics and aggregation:

    1. src/core/statistics_service.py with StatisticsService class:
       - __init__(self, db: DatabaseManager)
       - get_summary_stats() -> SummaryStats
       - get_stats_by_hold_type() -> dict[str, int]
       - get_stats_by_age_bracket() -> dict[str, int]
       - get_stats_by_license() -> dict[str, int]
       - get_stats_by_company() -> dict[str, int]
       - get_stats_by_size_bracket() -> dict[str, int]

    2. SummaryStats dataclass:
       - total_mailboxes: int
       - with_holds: int
       - without_holds: int
       - recovery_eligible: int
       - recovery_blocked: int
       - total_size_gb: float
       - avg_age_days: float
       - oldest_mailbox_days: int
       - newest_mailbox_days: int

    3. Age bracket definitions:
       - "< 30 days": 0-29
       - "30-90 days": 30-89
       - "90-180 days": 90-179
       - "180-365 days": 180-364
       - "> 1 year": 365+
       - "> 2 years": 730+

    4. Size bracket definitions:
       - "< 100 MB": 0-99
       - "100 MB - 1 GB": 100-1023
       - "1-5 GB": 1024-5119
       - "5-10 GB": 5120-10239
       - "> 10 GB": 10240+

    SQL aggregation for efficiency:
    ```sql
    SELECT
      CASE
        WHEN age_days < 30 THEN '< 30 days'
        WHEN age_days < 90 THEN '30-90 days'
        ...
      END as bracket,
      COUNT(*) as count
    FROM inactive_mailboxes
    GROUP BY bracket
    ```
  </action>
  <verify>python -c "from src.core.statistics_service import StatisticsService, SummaryStats; print('StatisticsService imported')"</verify>
  <done>Statistics service provides aggregations by all dimensions</done>
</task>

<task type="auto">
  <name>Task 3: Add basic data export</name>
  <files>src/core/export_service.py</files>
  <action>
    Create basic export functionality (full export in Phase 4):

    1. ExportService class:
       - __init__(self, db: DatabaseManager, audit: AuditLogger)
       - export_to_csv(mailboxes: list[InactiveMailbox], path: Path) -> int
       - export_to_json(mailboxes: list[InactiveMailbox], path: Path) -> int
       - export_filtered(criteria: FilterCriteria, path: Path, format: str) -> int

    2. CSV export:
       - Use csv.DictWriter
       - Include all relevant columns
       - Handle special characters and encoding (UTF-8 BOM for Excel)
       - Flatten hold_types and recovery_blockers lists

    3. JSON export:
       - Pretty-printed JSON
       - Include metadata (export date, filter criteria, count)

    4. Export with audit logging:
       - Log export operations to audit trail
       - Include: path, format, record count, filter criteria

    5. Column mapping for export:
       ```python
       EXPORT_COLUMNS = [
           ("identity", "Exchange GUID"),
           ("display_name", "Display Name"),
           ("primary_smtp", "Email Address"),
           ("when_soft_deleted", "Deleted Date"),
           ("age_days", "Age (Days)"),
           ("size_mb", "Size (MB)"),
           ("item_count", "Item Count"),
           ("license_type", "License"),
           ("hold_types", "Holds"),
           ("recovery_eligible", "Recovery Eligible"),
           ("recovery_blockers", "Blockers"),
       ]
       ```

    Excel export with charts will be in Phase 4.
  </action>
  <verify>python -c "from src.core.export_service import ExportService; print('ExportService imported')"</verify>
  <done>CSV and JSON export works, audit logging captures exports</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] FilterService filters by all criteria
- [ ] Search finds mailboxes by name/email
- [ ] StatisticsService provides accurate aggregations
- [ ] CSV export produces valid file
- [ ] JSON export includes metadata
- [ ] All operations are logged to audit trail
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Filtering is efficient (uses database indexes)
- Statistics match actual data
- Exports are properly formatted
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-discovery/02-03-SUMMARY.md`

**Phase 2 Complete Checklist:**
- [ ] Mailbox inventory retrieval working
- [ ] Hold analysis complete and accurate
- [ ] Filtering by all dimensions
- [ ] Search functionality
- [ ] Statistics and aggregations
- [ ] Basic export (CSV, JSON)
</output>
