---
phase: 03-operations
plan: 01
type: execute
---

<objective>
Implement pre-flight validation and recovery wizard for inactive mailbox recovery.

Purpose: Enable safe recovery of inactive mailboxes with comprehensive validation.
Output: Working recovery validator and wizard that prevents common recovery failures.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-discovery/02-02-SUMMARY.md

**From PROJECT.md:**
- Pre-flight validation detects recovery blockers (AuxPrimary, auto-expanding archives)
- Guided recovery wizard creates new active mailbox from inactive with full validation
- Risk: UPN/SMTP mismatches can cause permanent deletion locks
- Risk: Failed recoveries due to undiscovered AuxPrimary shards

**Recovery blockers to detect:**
1. AuxPrimary shard mailbox (cannot recover directly)
2. Auto-expanding archive enabled (special handling)
3. Active holds that must be removed first
4. UPN/SMTP conflicts with existing mailboxes
5. Soft-deleted user with same identity in recycle bin

**Recovery command (from research):**
```powershell
New-Mailbox -InactiveMailbox <InactiveMailboxGUID> -Name "DisplayName" -FirstName "First" -LastName "Last" -DisplayName "Display Name" -MicrosoftOnlineServicesID "newuser@domain.com" -Password (ConvertTo-SecureString -String 'TempP@ssw0rd!' -AsPlainText -Force) -ResetPasswordOnNextLogon $true
```

**Available from Phase 2:**
- HoldAnalyzer for hold detection and removal eligibility
- MailboxService for mailbox data
- CommandBuilder for safe PowerShell generation
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create recovery validator service</name>
  <files>src/core/recovery_validator.py</files>
  <action>
    Create comprehensive pre-flight validation:

    1. ValidationResult dataclass:
       - is_valid: bool
       - can_proceed: bool (valid or has warnings only)
       - errors: list[ValidationError]
       - warnings: list[ValidationWarning]
       - blockers: list[str]
       - recommendations: list[str]

    2. ValidationError and ValidationWarning dataclasses:
       - code: str (e.g., "AUXPRIMARY_SHARD")
       - message: str
       - severity: str (error, warning, info)
       - resolution: str | None

    3. RecoveryValidator class:
       - __init__(self, session: SessionManager)
       - validate_recovery(identity: str) -> ValidationResult
       - check_auxprimary_shard(identity: str) -> ValidationError | None
       - check_auto_expanding_archive(identity: str) -> ValidationError | None
       - check_active_holds(identity: str) -> list[ValidationWarning]
       - check_upn_conflicts(target_upn: str) -> ValidationError | None
       - check_smtp_conflicts(target_smtp: str) -> ValidationError | None
       - check_soft_deleted_user(identity: str) -> ValidationWarning | None

    4. Validation codes:
       - AUXPRIMARY_SHARD: Cannot recover AuxPrimary directly
       - AUTO_EXPANDING_ARCHIVE: Special handling required
       - ACTIVE_HOLDS: Holds must be addressed
       - UPN_CONFLICT: UPN already exists
       - SMTP_CONFLICT: SMTP address already in use
       - SOFT_DELETED_USER: User in recycle bin
       - LITIGATION_HOLD: Legal hold active
       - EDISCOVERY_HOLD: eDiscovery case hold

    Use CommandBuilder.build_recovery_preflight() for validation data.
  </action>
  <verify>python -c "from src.core.recovery_validator import RecoveryValidator, ValidationResult; print('RecoveryValidator imported')"</verify>
  <done>RecoveryValidator can perform all pre-flight checks</done>
</task>

<task type="auto">
  <name>Task 2: Create recovery operation service</name>
  <files>src/core/recovery_service.py</files>
  <action>
    Create recovery execution service:

    1. RecoveryRequest dataclass:
       - source_identity: str (inactive mailbox GUID)
       - target_upn: str (new user's UPN)
       - target_smtp: str (new primary SMTP)
       - display_name: str
       - first_name: str | None
       - last_name: str | None
       - password: str | None (auto-generate if not provided)
       - reset_password_on_logon: bool = True
       - department: str | None
       - company: str | None

    2. RecoveryResult dataclass:
       - success: bool
       - new_mailbox_guid: str | None
       - new_upn: str | None
       - error: str | None
       - validation_result: ValidationResult
       - execution_time_seconds: float
       - audit_id: int | None

    3. RecoveryService class:
       - __init__(self, session: SessionManager, validator: RecoveryValidator)
       - recover_mailbox(request: RecoveryRequest, skip_validation: bool = False) -> RecoveryResult
       - _execute_recovery(request: RecoveryRequest) -> RecoveryResult
       - _generate_password() -> str (secure random)
       - _build_recovery_command(request: RecoveryRequest) -> str
       - get_recovery_status(guid: str) -> str (check if complete)

    4. CommandBuilder additions:
       - build_new_mailbox_from_inactive(request: RecoveryRequest) -> str
       - build_check_mailbox_exists(upn: str) -> str
       - build_check_smtp_exists(smtp: str) -> str

    5. Audit logging:
       - Log recovery attempts with full details
       - Log validation results
       - Log success/failure with error details

    Password generation: Use secrets module for cryptographically secure passwords.
  </action>
  <verify>python -c "from src.core.recovery_service import RecoveryService, RecoveryRequest; print('RecoveryService imported')"</verify>
  <done>RecoveryService can execute recovery with validation</done>
</task>

<task type="auto">
  <name>Task 3: Create recovery wizard logic</name>
  <files>src/core/recovery_wizard.py</files>
  <action>
    Create guided recovery wizard:

    1. WizardStep enum:
       - SELECT_MAILBOX
       - VALIDATE_RECOVERY
       - ENTER_DETAILS
       - CONFIRM_RECOVERY
       - EXECUTE_RECOVERY
       - SHOW_RESULT

    2. WizardState dataclass:
       - current_step: WizardStep
       - selected_mailbox: InactiveMailbox | None
       - validation_result: ValidationResult | None
       - recovery_request: RecoveryRequest | None
       - recovery_result: RecoveryResult | None
       - errors: list[str]
       - can_proceed: bool
       - can_go_back: bool

    3. RecoveryWizard class:
       - __init__(self, session: SessionManager)
       - start() -> WizardState
       - select_mailbox(identity: str) -> WizardState
       - validate() -> WizardState
       - set_recovery_details(details: dict) -> WizardState
       - confirm() -> WizardState
       - execute() -> WizardState
       - go_back() -> WizardState
       - cancel() -> None
       - get_state() -> WizardState

    4. Wizard flow:
       - Step 1: User selects mailbox (search/browse)
       - Step 2: Auto-validate, show blockers/warnings
       - Step 3: Enter target UPN, SMTP, display name
       - Step 4: Review and confirm all details
       - Step 5: Execute recovery
       - Step 6: Show result with next steps

    5. Suggested values:
       - Suggest UPN based on original
       - Suggest SMTP from PrimarySmtpAddress
       - Suggest display name from original
       - Generate secure password

    This provides the logic layer; UI will be added in Phase 5/6.
  </action>
  <verify>python -c "from src.core.recovery_wizard import RecoveryWizard, WizardStep, WizardState; print('RecoveryWizard imported')"</verify>
  <done>RecoveryWizard provides guided recovery flow</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] RecoveryValidator detects all blocker types
- [ ] RecoveryService executes recovery with validation
- [ ] RecoveryWizard provides complete guided flow
- [ ] Audit logging captures all operations
- [ ] CommandBuilder has recovery commands
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Validation catches real blockers
- Recovery command is properly escaped
- Wizard state machine is complete
</success_criteria>

<output>
After completion, create `.planning/phases/03-operations/03-01-SUMMARY.md`
</output>
