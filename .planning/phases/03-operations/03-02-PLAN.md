---
phase: 03-operations
plan: 02
type: execute
---

<objective>
Implement restore operations to merge inactive mailbox content into existing mailboxes.

Purpose: Enable content restoration from inactive mailboxes to active mailboxes.
Output: Working restore service with conflict handling and progress tracking.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-operations/03-01-SUMMARY.md

**From PROJECT.md:**
- Restore operation merges inactive mailbox content into existing mailbox
- Conflict handling for duplicate items
- Real-time progress tracking

**Restore command (from research):**
```powershell
New-MailboxRestoreRequest -SourceMailbox <InactiveMailboxGUID> -TargetMailbox <TargetMailboxGUID> -AllowLegacyDNMismatch
```

**Restore options:**
- AllowLegacyDNMismatch: Allow restore even if legacy DN doesn't match
- TargetRootFolder: Specify subfolder for restored content
- ExcludeDumpster: Skip recoverable items
- ConflictResolutionOption: KeepSourceItem, KeepLatestItem, KeepAll

**Restore status tracking:**
```powershell
Get-MailboxRestoreRequest -Identity "user\MailboxRestore" | Get-MailboxRestoreRequestStatistics
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create restore request service</name>
  <files>src/core/restore_service.py</files>
  <action>
    Create restore operation service:

    1. RestoreRequest dataclass:
       - source_identity: str (inactive mailbox GUID)
       - target_identity: str (active mailbox GUID or UPN)
       - target_root_folder: str | None (default: "Restored-{date}")
       - allow_legacy_dn_mismatch: bool = True
       - exclude_dumpster: bool = False
       - conflict_resolution: str = "KeepAll" (KeepSourceItem, KeepLatestItem, KeepAll)
       - include_folders: list[str] | None
       - exclude_folders: list[str] | None
       - batch_name: str | None (for tracking multiple restores)

    2. RestoreResult dataclass:
       - success: bool
       - request_id: str | None
       - request_name: str | None
       - status: str (Queued, InProgress, Completed, Failed)
       - error: str | None
       - items_copied: int
       - items_skipped: int
       - bytes_copied: int
       - percent_complete: float
       - started_at: datetime | None
       - completed_at: datetime | None

    3. RestoreService class:
       - __init__(self, session: SessionManager)
       - create_restore_request(request: RestoreRequest) -> RestoreResult
       - get_restore_status(request_id: str) -> RestoreResult
       - get_all_restore_requests(batch_name: str | None = None) -> list[RestoreResult]
       - cancel_restore_request(request_id: str) -> bool
       - remove_restore_request(request_id: str) -> bool
       - wait_for_completion(request_id: str, timeout: int = 3600) -> RestoreResult

    4. CommandBuilder additions:
       - build_new_restore_request(request: RestoreRequest) -> str
       - build_get_restore_request_status(request_id: str) -> str
       - build_get_all_restore_requests(batch: str | None) -> str
       - build_cancel_restore_request(request_id: str) -> str
       - build_remove_restore_request(request_id: str) -> str

    Restore requests are async - they run in Exchange Online background.
  </action>
  <verify>python -c "from src.core.restore_service import RestoreService, RestoreRequest; print('RestoreService imported')"</verify>
  <done>RestoreService can create and track restore requests</done>
</task>

<task type="auto">
  <name>Task 2: Add restore validation and conflict handling</name>
  <files>src/core/restore_service.py (update), src/core/recovery_validator.py (update)</files>
  <action>
    Add restore-specific validation:

    1. Add to RecoveryValidator:
       - validate_restore(source: str, target: str) -> ValidationResult
       - check_target_mailbox_exists(target: str) -> ValidationError | None
       - check_target_has_space(target: str, source_size: int) -> ValidationWarning | None
       - check_existing_restore_request(source: str, target: str) -> ValidationError | None

    2. RestoreValidationCodes:
       - TARGET_NOT_FOUND: Target mailbox doesn't exist
       - TARGET_INACTIVE: Target is also inactive
       - INSUFFICIENT_SPACE: Target may not have enough quota
       - DUPLICATE_REQUEST: Restore request already exists
       - SOURCE_HAS_HOLDS: Source has active holds (warning)

    3. Add to RestoreService:
       - validate_restore(request: RestoreRequest) -> ValidationResult
       - estimate_restore_time(source_size_mb: float) -> int (seconds)
       - get_recommended_folder_name(source: InactiveMailbox) -> str

    4. Conflict resolution options explained:
       - KeepSourceItem: Always use source item (overwrite)
       - KeepLatestItem: Keep item with latest modified date
       - KeepAll: Keep both (may create duplicates)

    5. Default target folder naming:
       - "Restored-{DisplayName}-{Date}"
       - e.g., "Restored-John Smith-2024-01-15"
  </action>
  <verify>python -c "from src.core.restore_service import RestoreService; from src.core.recovery_validator import RecoveryValidator; print('Restore validation works')"</verify>
  <done>Restore validation prevents common errors</done>
</task>

<task type="auto">
  <name>Task 3: Add progress tracking and monitoring</name>
  <files>src/core/restore_service.py (update), src/core/operation_monitor.py</files>
  <action>
    Create operation monitoring:

    1. OperationStatus enum:
       - QUEUED
       - IN_PROGRESS
       - COMPLETED
       - COMPLETED_WITH_WARNINGS
       - FAILED
       - CANCELLED

    2. OperationProgress dataclass:
       - operation_id: str
       - operation_type: str (restore, recovery, bulk)
       - status: OperationStatus
       - percent_complete: float
       - items_processed: int
       - items_total: int
       - bytes_processed: int
       - bytes_total: int
       - current_item: str | None
       - started_at: datetime
       - estimated_completion: datetime | None
       - errors: list[str]
       - warnings: list[str]

    3. OperationMonitor class:
       - __init__(self, session: SessionManager)
       - start_monitoring(operation_id: str, operation_type: str) -> None
       - get_progress(operation_id: str) -> OperationProgress
       - poll_progress(operation_id: str, callback: Callable) -> None
       - stop_monitoring(operation_id: str) -> None
       - get_active_operations() -> list[OperationProgress]

    4. Progress callback pattern:
       ```python
       def progress_callback(progress: OperationProgress) -> None:
           print(f"{progress.percent_complete:.1f}% complete")

       monitor.poll_progress("restore_123", progress_callback)
       ```

    5. Integrate with RestoreService:
       - create_restore_request() returns operation_id for monitoring
       - wait_for_completion() uses OperationMonitor internally
  </action>
  <verify>python -c "from src.core.operation_monitor import OperationMonitor, OperationProgress, OperationStatus; print('OperationMonitor imported')"</verify>
  <done>Progress tracking works for restore operations</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] RestoreService creates restore requests
- [ ] Restore validation checks target mailbox
- [ ] OperationMonitor tracks progress
- [ ] Conflict resolution options work
- [ ] Status polling works correctly
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Restore requests created successfully
- Progress tracking is accurate
- Validation prevents invalid restores
</success_criteria>

<output>
After completion, create `.planning/phases/03-operations/03-02-SUMMARY.md`
</output>
